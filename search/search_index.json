{
    "docs": [
        {
            "location": "/",
            "text": "Monacs - documentation\n\n\nMonacs is a library that provides a set of types and functions that can be used to substantialy change the approach you use to write your C# code. And while it won't change object-oriented language into fully-featured functional language, it gives you oportunity to use some of the FP concepts in your C# code today.\n\n\n\n\nIntro\n\n\nQuick Start\n\n\nGlossary\n\n\nTypes\n\n\nOption\\\n\n\nResult\\\n\n\nErrorDetails",
            "title": "Index"
        },
        {
            "location": "/#monacs-documentation",
            "text": "Monacs is a library that provides a set of types and functions that can be used to substantialy change the approach you use to write your C# code. And while it won't change object-oriented language into fully-featured functional language, it gives you oportunity to use some of the FP concepts in your C# code today.   Intro  Quick Start  Glossary  Types  Option\\  Result\\  ErrorDetails",
            "title": "Monacs - documentation"
        },
        {
            "location": "/quickstart/",
            "text": "Quick Start\n\n\nUsing Monacs library is pretty easy. First, you have to install it into the project. You can do it from the UI in Visual Studio, using Package Manager Console:\n\n\nInstall-Package Monacs.Core\n\n\n\nIf you're using \ndotnet\n CLI you can do it as well:\n\n\ndotnet add package Monacs.Core\n\n\n\nCreating optional values\n\n\nNow, let's define some data structure which will have an optional field. If you were creating expense tracking system you may have a class like this:\n\n\nusing Monacs.Core;\n\npublic class Expense\n{\n    public ExpenseCategory Category { get; set; }\n    public decimal Amount { get; set; }\n    public Option<string> Notes { get; set; }\n}\n\n\n\nOption<T>\n is a generic struct that wraps any value and it annotates that given property, function parameter or result can be empty. Let's create object of \nExpense\n class and see it in action:\n\n\nusing Monacs.Core;\n...\npublic Expense CreateExpense(ExpenseCategory category, decimal amount, string notes) => new Expense\n{\n    Category = category,\n    Amount = amount,\n    Notes = string.IsNullOrEmpty(notes)\n        ? Option.Some(notes)\n        : Option.None<string>()\n}\n\n\n\nFirst thing you will notice is that there are no publicly available constructors for \nOption<T>\n type. You create them using \nSome\n and \nNone\n factory methods. This is because the type can only have two states (again \nSome\n and \nNone\n), and Monacs is doing everything to prevent you from having any other possibility here.\n\n\nOK, so now Notes field will be \nSome\n when \nnotes\n parameter was null or empty. The code to do it is quite verbose though. We can make it a bit shorter by leveraging \nusing static\n feature of C#. The code could look like this:\n\n\nusing static Monacs.Core.Option;\n...\npublic Expense CreateExpense(ExpenseCategory category, decimal amount, string notes) => new Expense\n{\n    Category = category,\n    Amount = amount,\n    Notes = string.IsNullOrEmpty(notes) ? Some(notes) : None<string>()\n}\n\n\n\nThings get nicer now. By statically importing \nOption\n class we can use methods defined there as they were defined in the same class we're in. \nOption\n class is a static class containing set of factory and extension methods that allow you to create and work with \nOption<T>\n struct.\n\n\nActually the code we've written there is so common that Monacs contains extension that does exact same thing:\n\n\nusing Monacs.Core;\n...\npublic Expense CreateExpense(ExpenseCategory category, decimal amount, string notes) => new Expense\n{\n    Category = category,\n    Amount = amount,\n    Notes = notes.ToOption()\n}\n\n\n\nThere are \nToOption()\n overloads that allow you to convert any reference type (None when null), nullable (None when null) and string (None when null or empty). You should use them instead of \nSome\n and \nNone\n factory methods whenever possible, as they prevent you from doing unwise things like this:\n\n\npublic static Option<T> ToEvilSome<T>(T value = null) where T : class =>\n    Option.Some(value);\n\n\n\nAs you may guess, this code will create \nSome\n state with potentially \nnull\n value - this isn't a very safe code, is it?\n\n\nWorking with optional values\n\n\nOnce you've created optional values you'll want to actually use it. Let's say you want to display notes when they are actually present, and display alternate text when it's empty. You can start by creating function like this:\n\n\nusing Monacs.Core;\n...\npublic string GetNotesText(Option<string> notes) =>\n    notes.IsSome\n    ? notes.Value\n    : \"There are no notes, sorry!\";\n\n\n\nUsing \nValue\n property is convenient, but you shouldn't actually do it unless necessary. In most functional languages you could use pattern matching as an alternative, but the one in C# (as of version 7.0) isn't powerful enough. But no worries, Monacs is here to help:\n\n\nusing Monacs.Core;\n...\npublic string GetNotesText(Option<string> notes) =>\n    notes.Match(\n        some: n => n.Value\n        none: () => \"There are no notes, sorry!\");\n\n\n\nNow you won't accidentally use \nValue\n when it's not present. \nMatch\n function is quite powerful, but it's also very very verbose. That's why for many common operations you can find helper methods in Monacs. Shorter version of the code above can look like this:\n\n\nusing Monacs.Core;\n...\npublic string GetNotesText(Option<string> notes) =>\n    notes.GetOrDefault(whenNone: \"There are no notes, sorry!\");\n\n\n\nCombining calls\n\n\nOnce you got an optional value, you may want to transform it in one way or another. Getting back to the notes example, let's assume that the editor allows you to use Markdown for formatting and you want to get the word count from your field. To make it clear what are you doing you want to make it explicit, so the code can look like this:\n\n\nusing Monacs.Core;\n...\npublic int GetWordCount(Option<string> notes)\n{\n    if (notes.IsNone)\n        return 0;\n    var strippedNotes = RemoveFormatting(notes.Value);\n    return GetWordCount(strippedNotes);\n}\n\n\n\nAs with earlier example, you can accidentaly use the Value when it's not set, so you probably want to use a bit different approach. With Monacs you can do it like this:\n\n\nusing Monacs.Core;\n...\npublic int GetWordCount(Option<string> notes) =>\n    notes\n        .Map(RemoveFormatting)\n        .Map(GetWordCount)\n        .GetOrDefault();\n\n\n\nNow the code is only using \nValue\n when it's actually set. Another important change is that the code is now an expression instead of set of instructions, making code briefer and removing unnecessary noise.\n\n\nSo you may ask what is this \nMap\n function? If you've ever used LINQ then probably you know \nSelect\n function from it. \nMap\n is exactly the same thing, just operating on \nOption<T>\n instead of \nIEnumerable<T>\n. It takes in the option (as an extension of it) and a mapper function that accepts one value and returns other value. The signature of mapper in C# convention is \nFunc<T1, T2>\n. Mapper is executed only when input option is \nSome\n, and it will return it's result wrapped into \nSome\n. Otherwise, it will return \nNone<T2>\n. If the function above was to return \nOption<int>\n, giving \nNone\n when there are no notes, code without \nMap\n could look like this:\n\n\nusing Monacs.Core;\nusing static Monacs.Core.Option;\n...\npublic Option<int> GetWordCount(Option<string> notes)\n{\n    if (notes.IsNone)\n        return None<int>();\n    var strippedNotes = RemoveFormatting(notes.Value);\n    var wordCount = GetWordCount(strippedNotes);\n    return Some(wordCount);\n}\n\n\n\nUsing \nMap\n it gets much simpler (and safer):\n\n\nusing Monacs.Core;\n...\npublic Option<int> GetWordCount(Option<string> notes) =>\n    notes.Map(RemoveFormatting).Map(GetWordCount);\n\n\n\nSo \nMap\n is really nice helper function, but what would happen if the \nGetWordCount\n function was returning \nOption<int>\n, giving \nNone\n when there are no words? We would get compile error that the value returned doesn't match function signature. Now it would be \nOption<Option<int>>\n, which doesn't look good. Fortunatelly there is one more function that can solve this particular problem. It's called \nBind\n. Let's see it in action, given the described case:\n\n\nusing Monacs.Core;\n...\npublic Option<int> GetWordCount(Option<string> notes) =>\n    notes.Map(RemoveFormatting).Bind(GetWordCount);\n\n\n\nNow the returned value matches the signature again. We're good to go. So what's this \nBind\n function? It is very similar to \nMap\n, the difference being signature of the function it accepts as a parameter. In \nBind\n it's \nFunc<T1, Option<T2>>\n and it's called \nbinder\n. If the input to \nBind\n is \nSome\n, it will return result of \nbinder\n without wrapping it into \nSome\n, so it will actually return \nNone\n when \nbinder\n returns \nNone\n. That allows for even more composability.\n\n\nThis should give you a brief overview of how to work with \nOption<T>\n type, but what about \nResult<T>\n? It turns out it works in the same way, so let's explore the differences.\n\n\nWorking with \nResult<T>\n\n\nSimilar to \nOption<T>\n, \nResult<T>\n type\n is a struct and has two possible states - \nOk\n with a data of type \nT\n in the \nValue\n property, and \nError\n with a data of \ntype \nErrorDetails\n in the \nError\n property. This makes it perfect candidate for second common case, where you have a function and it may fail to execute properly. Usualy in such case you can expect an exception to be thrown. The problem with exceptions is that you don't have any explicit way to say that the function may fail and which exceptions it may throw (apart from comments). Handling exceptions is also problematic, as you need to decide when to wrap the code into \ntry...catch\n - having it everywhere requires a lot of code, and it's also impacting performance quite substantialy. So just like \nOption<T>\n mitigates the problem of null, \nResult<T>\n deals with exceptions.\n\n\nThere is very similar set of extensions provided for \nResult<T>\n to the ones for \nOption<T>\n. The most important ones like \nBind\n, \nMap\n and \nMatch\n are there, as well as many others. There are also async versions of them, provided in \nMonacs.Core.Async\n namespace, such as \nBindAsync\n or \nMapAsync\n. You can then operate on \nTask<Result<T>>\n, have async \nbinder\n or \nmapper\n functions and so on. One thing to remember is that once you jump into async code, you will have to keep using async variants to the the end of the function chain - until you await on the chain and get the underlying \nResult<T>\n. See the example below:\n\n\npublic async Task<Result<Unit>> UpdateCustomerAddress(UpdateCustomerAddressDto newCustomerAddress)\n{\n    var result = await Validate(newCustomerAddress)\n        // Validate returns Result<UpdateCustomerAddressDto>\n        .BindAsync(newAddress => GetCustomer(newAddress.Id).MapAsync(customer => (customer, newAddress)))\n        // GetCustomer returns Task<Result<Customer>>, so we use MapAsync\n        .MapAsync(UpdateCustomerAddress)\n        // UpdateCustomerAddress takes tuple of Customer and UpdateCustomerAddressDto and returns Result<Customer>\n        .BindAsync(PersistCustomer)\n        // PersistCustomer returns Task<Result<Customer>>\n        .DoWhenErrorAsync(LogError);\n\n    return result.Ignore();\n    // result is now Result<Customer>, we can ignore the value (if we use CQRS approach) using non-async extension\n}\n\n\n\nYou can find list of available extensions in the \nAPI documentation\n.\n\n\nUnit\n - type representing no value\n\n\nTo avoid need to duplicate the APIs for the functions that don't need to return anything (defined as \nvoid\n in C#) Monacs uses \nUnit\n type\n, known from other languages (like F#) and libraries (like Reactive Extensions). \nUnit\n Has only one value and it's available as \nUnit.Default\n property. You can use it as a substitute for any type whenever you need some, but you don't care about the value, e.g. you can return \nTask<Unit>\n (equivalent of non-generic \nTask\n) or \nFunc<T>\n instead of \nAction\n. \nResult<Unit>\n can be used as a return type for functions with side effects that don't return any value, e.g. saving data to the database. There are some additional extensions provided for \nResult<Unit>\n in \nMonacs.Core.Unit\n namespace, like the mentioned above \nIgnore\n function.",
            "title": "Quick Start"
        },
        {
            "location": "/quickstart/#quick-start",
            "text": "Using Monacs library is pretty easy. First, you have to install it into the project. You can do it from the UI in Visual Studio, using Package Manager Console:  Install-Package Monacs.Core  If you're using  dotnet  CLI you can do it as well:  dotnet add package Monacs.Core",
            "title": "Quick Start"
        },
        {
            "location": "/quickstart/#creating-optional-values",
            "text": "Now, let's define some data structure which will have an optional field. If you were creating expense tracking system you may have a class like this:  using Monacs.Core;\n\npublic class Expense\n{\n    public ExpenseCategory Category { get; set; }\n    public decimal Amount { get; set; }\n    public Option<string> Notes { get; set; }\n}  Option<T>  is a generic struct that wraps any value and it annotates that given property, function parameter or result can be empty. Let's create object of  Expense  class and see it in action:  using Monacs.Core;\n...\npublic Expense CreateExpense(ExpenseCategory category, decimal amount, string notes) => new Expense\n{\n    Category = category,\n    Amount = amount,\n    Notes = string.IsNullOrEmpty(notes)\n        ? Option.Some(notes)\n        : Option.None<string>()\n}  First thing you will notice is that there are no publicly available constructors for  Option<T>  type. You create them using  Some  and  None  factory methods. This is because the type can only have two states (again  Some  and  None ), and Monacs is doing everything to prevent you from having any other possibility here.  OK, so now Notes field will be  Some  when  notes  parameter was null or empty. The code to do it is quite verbose though. We can make it a bit shorter by leveraging  using static  feature of C#. The code could look like this:  using static Monacs.Core.Option;\n...\npublic Expense CreateExpense(ExpenseCategory category, decimal amount, string notes) => new Expense\n{\n    Category = category,\n    Amount = amount,\n    Notes = string.IsNullOrEmpty(notes) ? Some(notes) : None<string>()\n}  Things get nicer now. By statically importing  Option  class we can use methods defined there as they were defined in the same class we're in.  Option  class is a static class containing set of factory and extension methods that allow you to create and work with  Option<T>  struct.  Actually the code we've written there is so common that Monacs contains extension that does exact same thing:  using Monacs.Core;\n...\npublic Expense CreateExpense(ExpenseCategory category, decimal amount, string notes) => new Expense\n{\n    Category = category,\n    Amount = amount,\n    Notes = notes.ToOption()\n}  There are  ToOption()  overloads that allow you to convert any reference type (None when null), nullable (None when null) and string (None when null or empty). You should use them instead of  Some  and  None  factory methods whenever possible, as they prevent you from doing unwise things like this:  public static Option<T> ToEvilSome<T>(T value = null) where T : class =>\n    Option.Some(value);  As you may guess, this code will create  Some  state with potentially  null  value - this isn't a very safe code, is it?",
            "title": "Creating optional values"
        },
        {
            "location": "/quickstart/#working-with-optional-values",
            "text": "Once you've created optional values you'll want to actually use it. Let's say you want to display notes when they are actually present, and display alternate text when it's empty. You can start by creating function like this:  using Monacs.Core;\n...\npublic string GetNotesText(Option<string> notes) =>\n    notes.IsSome\n    ? notes.Value\n    : \"There are no notes, sorry!\";  Using  Value  property is convenient, but you shouldn't actually do it unless necessary. In most functional languages you could use pattern matching as an alternative, but the one in C# (as of version 7.0) isn't powerful enough. But no worries, Monacs is here to help:  using Monacs.Core;\n...\npublic string GetNotesText(Option<string> notes) =>\n    notes.Match(\n        some: n => n.Value\n        none: () => \"There are no notes, sorry!\");  Now you won't accidentally use  Value  when it's not present.  Match  function is quite powerful, but it's also very very verbose. That's why for many common operations you can find helper methods in Monacs. Shorter version of the code above can look like this:  using Monacs.Core;\n...\npublic string GetNotesText(Option<string> notes) =>\n    notes.GetOrDefault(whenNone: \"There are no notes, sorry!\");",
            "title": "Working with optional values"
        },
        {
            "location": "/quickstart/#combining-calls",
            "text": "Once you got an optional value, you may want to transform it in one way or another. Getting back to the notes example, let's assume that the editor allows you to use Markdown for formatting and you want to get the word count from your field. To make it clear what are you doing you want to make it explicit, so the code can look like this:  using Monacs.Core;\n...\npublic int GetWordCount(Option<string> notes)\n{\n    if (notes.IsNone)\n        return 0;\n    var strippedNotes = RemoveFormatting(notes.Value);\n    return GetWordCount(strippedNotes);\n}  As with earlier example, you can accidentaly use the Value when it's not set, so you probably want to use a bit different approach. With Monacs you can do it like this:  using Monacs.Core;\n...\npublic int GetWordCount(Option<string> notes) =>\n    notes\n        .Map(RemoveFormatting)\n        .Map(GetWordCount)\n        .GetOrDefault();  Now the code is only using  Value  when it's actually set. Another important change is that the code is now an expression instead of set of instructions, making code briefer and removing unnecessary noise.  So you may ask what is this  Map  function? If you've ever used LINQ then probably you know  Select  function from it.  Map  is exactly the same thing, just operating on  Option<T>  instead of  IEnumerable<T> . It takes in the option (as an extension of it) and a mapper function that accepts one value and returns other value. The signature of mapper in C# convention is  Func<T1, T2> . Mapper is executed only when input option is  Some , and it will return it's result wrapped into  Some . Otherwise, it will return  None<T2> . If the function above was to return  Option<int> , giving  None  when there are no notes, code without  Map  could look like this:  using Monacs.Core;\nusing static Monacs.Core.Option;\n...\npublic Option<int> GetWordCount(Option<string> notes)\n{\n    if (notes.IsNone)\n        return None<int>();\n    var strippedNotes = RemoveFormatting(notes.Value);\n    var wordCount = GetWordCount(strippedNotes);\n    return Some(wordCount);\n}  Using  Map  it gets much simpler (and safer):  using Monacs.Core;\n...\npublic Option<int> GetWordCount(Option<string> notes) =>\n    notes.Map(RemoveFormatting).Map(GetWordCount);  So  Map  is really nice helper function, but what would happen if the  GetWordCount  function was returning  Option<int> , giving  None  when there are no words? We would get compile error that the value returned doesn't match function signature. Now it would be  Option<Option<int>> , which doesn't look good. Fortunatelly there is one more function that can solve this particular problem. It's called  Bind . Let's see it in action, given the described case:  using Monacs.Core;\n...\npublic Option<int> GetWordCount(Option<string> notes) =>\n    notes.Map(RemoveFormatting).Bind(GetWordCount);  Now the returned value matches the signature again. We're good to go. So what's this  Bind  function? It is very similar to  Map , the difference being signature of the function it accepts as a parameter. In  Bind  it's  Func<T1, Option<T2>>  and it's called  binder . If the input to  Bind  is  Some , it will return result of  binder  without wrapping it into  Some , so it will actually return  None  when  binder  returns  None . That allows for even more composability.  This should give you a brief overview of how to work with  Option<T>  type, but what about  Result<T> ? It turns out it works in the same way, so let's explore the differences.",
            "title": "Combining calls"
        },
        {
            "location": "/quickstart/#working-with-resultt",
            "text": "Similar to  Option<T> ,  Result<T>  type  is a struct and has two possible states -  Ok  with a data of type  T  in the  Value  property, and  Error  with a data of  type  ErrorDetails  in the  Error  property. This makes it perfect candidate for second common case, where you have a function and it may fail to execute properly. Usualy in such case you can expect an exception to be thrown. The problem with exceptions is that you don't have any explicit way to say that the function may fail and which exceptions it may throw (apart from comments). Handling exceptions is also problematic, as you need to decide when to wrap the code into  try...catch  - having it everywhere requires a lot of code, and it's also impacting performance quite substantialy. So just like  Option<T>  mitigates the problem of null,  Result<T>  deals with exceptions.  There is very similar set of extensions provided for  Result<T>  to the ones for  Option<T> . The most important ones like  Bind ,  Map  and  Match  are there, as well as many others. There are also async versions of them, provided in  Monacs.Core.Async  namespace, such as  BindAsync  or  MapAsync . You can then operate on  Task<Result<T>> , have async  binder  or  mapper  functions and so on. One thing to remember is that once you jump into async code, you will have to keep using async variants to the the end of the function chain - until you await on the chain and get the underlying  Result<T> . See the example below:  public async Task<Result<Unit>> UpdateCustomerAddress(UpdateCustomerAddressDto newCustomerAddress)\n{\n    var result = await Validate(newCustomerAddress)\n        // Validate returns Result<UpdateCustomerAddressDto>\n        .BindAsync(newAddress => GetCustomer(newAddress.Id).MapAsync(customer => (customer, newAddress)))\n        // GetCustomer returns Task<Result<Customer>>, so we use MapAsync\n        .MapAsync(UpdateCustomerAddress)\n        // UpdateCustomerAddress takes tuple of Customer and UpdateCustomerAddressDto and returns Result<Customer>\n        .BindAsync(PersistCustomer)\n        // PersistCustomer returns Task<Result<Customer>>\n        .DoWhenErrorAsync(LogError);\n\n    return result.Ignore();\n    // result is now Result<Customer>, we can ignore the value (if we use CQRS approach) using non-async extension\n}  You can find list of available extensions in the  API documentation .",
            "title": "Working with Result&lt;T&gt;"
        },
        {
            "location": "/quickstart/#unit-type-representing-no-value",
            "text": "To avoid need to duplicate the APIs for the functions that don't need to return anything (defined as  void  in C#) Monacs uses  Unit  type , known from other languages (like F#) and libraries (like Reactive Extensions).  Unit  Has only one value and it's available as  Unit.Default  property. You can use it as a substitute for any type whenever you need some, but you don't care about the value, e.g. you can return  Task<Unit>  (equivalent of non-generic  Task ) or  Func<T>  instead of  Action .  Result<Unit>  can be used as a return type for functions with side effects that don't return any value, e.g. saving data to the database. There are some additional extensions provided for  Result<Unit>  in  Monacs.Core.Unit  namespace, like the mentioned above  Ignore  function.",
            "title": "Unit - type representing no value"
        },
        {
            "location": "/option/",
            "text": "Monacs.Core.Option\n\n\nOption<T>\n type is an implementation of Maybe monad. It has two possible states - default one representing absence of value (\nNone\n) and the other one representing presence of value (\nSome\n). \nOption<T>\n wraps value that can be absent, in similar way as \nNullable<T>\n wraps value types. The are core differences though. While \nNullable<T>\n only wraps structs (value types), \nOption<T>\n works with all kinds of types, making things more consistent. The value representing absence of data in \nNullable<T>\n is the same as for reference types - both use \nnull\n for that purpose. With \nOption<T>\n you don't really care what is the value representing absence of data, because it's the property of the type itself.\n\n\nWhen to use it\n\n\nThe main use case of \nOption\n type is modeling properties of data structures which are not required to create given structure. Let's say we want to build expense tracking system and need to model Expense enity. To make things simple, we want it to contain 3 properties: category, amount and optional notes. We may start with creating it like this:\n\n\npublic class Expense\n{\n    public ExpenseCategory Category { get; set; }\n    public decimal Amount { get; set; }\n    public string Notes { get; set; }\n}\n\n\n\nThis design has quite a few flaws, one of them is the fact that we don't state explicitly which properties are required and which are optional. Let's make a simple change:\n\n\npublic class Expense\n{\n    public ExpenseCategory Category { get; set; }\n    public decimal Amount { get; set; }\n    public Option<string> Notes { get; set; }\n}\n\n\n\nNow we explicitly say that Notes can be present or not. That not only applies to the structure of the class, but also to the usage.\n\n\npublic string GetExpenseNotesUppercase(Expense expense) =>\n    expense.Notes.ToUpper();\n\n\n\nThe problem with the code above is that it will crash badly with \nNullReferenceException\n if the Notes field is null. Of course we can fix that:\n\n\npublic string GetExpenseNotesUppercase(Expense expense) =>\n    expense.Notes?.ToUpper();\n\n\n\nNot much more complicated, but we only postponed the the issue to the caller - we'll return \nnull\n if the value was \nnull\n in the first place. Of course we could make it return some proper value each time:\n\n\npublic string GetExpenseNotesUppercase(Expense expense) =>\n    expense.Notes?.ToUpper() ?? string.Empty;\n\n\n\nBut we get to the same issue that we had with our data structure - we don't state if the return value will always be present. Consumers of this method still need to consider \nnull\n case - just in case you decide to change the internal implementation details.\n\n\nNow let's see how it can look with \nOption<T>\n type:\n\n\npublic Option<string> GetExpenseNotesUppercase(Expense expense) =>\n    expense.Notes.Map(s => s.ToUpper());\n\n\n\nNote that signature of the function has changed, and now we say explicitly that you may not get the value. Consumers will need to handle it directly, making it harder to get unexpected errors.\n\n\nOne other benefit is that you can have now consistent way of checking if the value is there - just by checking \nIsSome\n or \nIsNone\n property of the option. If you, for example, would like to hide the Notes field in the UI, you've got it for free. But it doesn't stop there.\n\n\nHow to use it\n\n\nHaving one type to wrap all the optional values gives you the power to extend things easily. If you've ever used LINQ, you should already know how convenient it can be. Actually the \nOption<T>\n type has the same superpowers as \nIEnumerable<T>\n, allowing you to chain calls as long as your inputs and outputs are options (fluent APIs, anyone?). Take a look at this example. Let's say that we want to extract the list of hashtags present in the \nNotes\n field mentioned above, and also make all of them lowercase.\n\n\npublic Option<IEnumerable<string>> GetHashtags(string s) {...}\n\npublic Option<List<string>> GetNotesHashtags(Expense expense) =>\n    expense.Notes\n        .Map(s => s.ToLower())\n        .Bind(GetHashtags);\n        .Map(x => x.ToList());\n\n\n\nAbove code is actually equivalent to this:\n\n\npublic Option<List<string>> GetNotesHashtags(Expense expense)\n{\n    if (expense.Notes.IsNone)\n        return Option.None<List<string>>();\n    var lowercaseNotes = expense.Notes.Value.ToLower();\n    var hashtags = lowercaseNotes.GetHashtags(s);\n    if (hashtags.IsNone)\n        return Option.None<List<string>>();\n    return hashtags.ToList();\n}\n\n\n\nNot only there is less code to write and read in the first example, but it also reduces the need for naming things.\n\n\nYou can also reimplement it without option at all, for example like this:\n\n\npublic List<string> GetNotesHashtags(Expense expense)\n{\n    if (string.IsNullOrEmpty(expense.Notes))\n        return null;\n    var lowercaseNotes = expense.Notes.ToLower();\n    var hashtags = lowercaseNotes.GetHashtags(s);\n    return hashtags?.ToList();\n}\n\n\n\nThis seems like a good option, especially with null propagation operator in C# being very convenient, but one thing you have to remember is that it doesn't solve the problem of null. It only moves the responsibility of handling it from one piece of code to another.\n\n\nSummary\n\n\nAs you can see, option type has quite a few benefits:\n\n\n\n\nexplicity - you state in a very obvious way that something may be not present\n\n\nbrevity - with just a few helpers you can make code much more concise\n\n\nextensibility - the same simple helpers build powerful fluent API\n\n\nsafety - you substantialy reduce the risk of having \nNullReferenceException\n\n\nversality - the same type represents the lack of value for structs and classes\n\n\n\n\nWhen you start using it, you realize that it is a sweet spot between convenience of simple null propagation and complexity of multi-level null handling.",
            "title": "Option"
        },
        {
            "location": "/option/#monacscoreoption",
            "text": "Option<T>  type is an implementation of Maybe monad. It has two possible states - default one representing absence of value ( None ) and the other one representing presence of value ( Some ).  Option<T>  wraps value that can be absent, in similar way as  Nullable<T>  wraps value types. The are core differences though. While  Nullable<T>  only wraps structs (value types),  Option<T>  works with all kinds of types, making things more consistent. The value representing absence of data in  Nullable<T>  is the same as for reference types - both use  null  for that purpose. With  Option<T>  you don't really care what is the value representing absence of data, because it's the property of the type itself.",
            "title": "Monacs.Core.Option"
        },
        {
            "location": "/option/#when-to-use-it",
            "text": "The main use case of  Option  type is modeling properties of data structures which are not required to create given structure. Let's say we want to build expense tracking system and need to model Expense enity. To make things simple, we want it to contain 3 properties: category, amount and optional notes. We may start with creating it like this:  public class Expense\n{\n    public ExpenseCategory Category { get; set; }\n    public decimal Amount { get; set; }\n    public string Notes { get; set; }\n}  This design has quite a few flaws, one of them is the fact that we don't state explicitly which properties are required and which are optional. Let's make a simple change:  public class Expense\n{\n    public ExpenseCategory Category { get; set; }\n    public decimal Amount { get; set; }\n    public Option<string> Notes { get; set; }\n}  Now we explicitly say that Notes can be present or not. That not only applies to the structure of the class, but also to the usage.  public string GetExpenseNotesUppercase(Expense expense) =>\n    expense.Notes.ToUpper();  The problem with the code above is that it will crash badly with  NullReferenceException  if the Notes field is null. Of course we can fix that:  public string GetExpenseNotesUppercase(Expense expense) =>\n    expense.Notes?.ToUpper();  Not much more complicated, but we only postponed the the issue to the caller - we'll return  null  if the value was  null  in the first place. Of course we could make it return some proper value each time:  public string GetExpenseNotesUppercase(Expense expense) =>\n    expense.Notes?.ToUpper() ?? string.Empty;  But we get to the same issue that we had with our data structure - we don't state if the return value will always be present. Consumers of this method still need to consider  null  case - just in case you decide to change the internal implementation details.  Now let's see how it can look with  Option<T>  type:  public Option<string> GetExpenseNotesUppercase(Expense expense) =>\n    expense.Notes.Map(s => s.ToUpper());  Note that signature of the function has changed, and now we say explicitly that you may not get the value. Consumers will need to handle it directly, making it harder to get unexpected errors.  One other benefit is that you can have now consistent way of checking if the value is there - just by checking  IsSome  or  IsNone  property of the option. If you, for example, would like to hide the Notes field in the UI, you've got it for free. But it doesn't stop there.",
            "title": "When to use it"
        },
        {
            "location": "/option/#how-to-use-it",
            "text": "Having one type to wrap all the optional values gives you the power to extend things easily. If you've ever used LINQ, you should already know how convenient it can be. Actually the  Option<T>  type has the same superpowers as  IEnumerable<T> , allowing you to chain calls as long as your inputs and outputs are options (fluent APIs, anyone?). Take a look at this example. Let's say that we want to extract the list of hashtags present in the  Notes  field mentioned above, and also make all of them lowercase.  public Option<IEnumerable<string>> GetHashtags(string s) {...}\n\npublic Option<List<string>> GetNotesHashtags(Expense expense) =>\n    expense.Notes\n        .Map(s => s.ToLower())\n        .Bind(GetHashtags);\n        .Map(x => x.ToList());  Above code is actually equivalent to this:  public Option<List<string>> GetNotesHashtags(Expense expense)\n{\n    if (expense.Notes.IsNone)\n        return Option.None<List<string>>();\n    var lowercaseNotes = expense.Notes.Value.ToLower();\n    var hashtags = lowercaseNotes.GetHashtags(s);\n    if (hashtags.IsNone)\n        return Option.None<List<string>>();\n    return hashtags.ToList();\n}  Not only there is less code to write and read in the first example, but it also reduces the need for naming things.  You can also reimplement it without option at all, for example like this:  public List<string> GetNotesHashtags(Expense expense)\n{\n    if (string.IsNullOrEmpty(expense.Notes))\n        return null;\n    var lowercaseNotes = expense.Notes.ToLower();\n    var hashtags = lowercaseNotes.GetHashtags(s);\n    return hashtags?.ToList();\n}  This seems like a good option, especially with null propagation operator in C# being very convenient, but one thing you have to remember is that it doesn't solve the problem of null. It only moves the responsibility of handling it from one piece of code to another.",
            "title": "How to use it"
        },
        {
            "location": "/option/#summary",
            "text": "As you can see, option type has quite a few benefits:   explicity - you state in a very obvious way that something may be not present  brevity - with just a few helpers you can make code much more concise  extensibility - the same simple helpers build powerful fluent API  safety - you substantialy reduce the risk of having  NullReferenceException  versality - the same type represents the lack of value for structs and classes   When you start using it, you realize that it is a sweet spot between convenience of simple null propagation and complexity of multi-level null handling.",
            "title": "Summary"
        },
        {
            "location": "/result/",
            "text": "Monacs.Core.Result\n\n\nResult<T>\n type is a monad encapsulating common case when function call may end up with success or error. It has two possible states - one representing successful execution and a value being returned (\nOk\n) and the other one representing error in execution (\nError\n). You can find some similarities to Either, IO or Task monads, if you're familiar with any of those. It is meant to inform consumer of the function that the execution may not finish successfully (very often due to external side effects) and suggests handling such case on the consumer side. The most common examples would be any functions performing IO tasks. If such operation fails, the author of the function should provide all needed details in the \nError\n property, described by the \nErrorDetails\n class\n.\n\n\nWhen to use it\n\n\nWhenever you are creating a function which calls other functions that are known to throw exceptions or return errors of other kind, you face a dillema. You can either let the error to bubble up or handle it in-place. With the first approach in most cases you lose the explicitness, as you don't inform consumers that they should handle the error. There is always a problem when is the right moment to stop bubbling up which often leads to unhandled exceptions.\n\n\npublic Expense GetExpenseById(Guid id) =>\n    _httpClient.GetJson<Expense>(RootUrl + $\"/expenses/{id}\"); // Happy path, no exception handling\n\n\n\nThe solution for this could be handling the exception at the source, so the second approach. In this case the problem is usually deciding what kind of value you should return to the calling function, or how to stop further execution without breaking whole application.\n\n\npublic Expense GetExpenseById(Guid id)\n{\n    try\n    {\n        return _httpClient.GetJson<Expense>(RootUrl + $\"/expenses/{id}\"); // Happy path, no exception handling\n    }\n    catch (Exception ex)\n    {\n        _logger.Error($\"Could not get the expence with id {id}\", ex);\n        throw; // bubble up anyway\n        // or\n        return null; // return evil value\n    }\n}\n\n\n\nThis is where \nResult<T>\n comes in. You can handle the exception close to the source, provide meaningful error details and inform calling function about the failure.\n\n\npublic Result<Expense> GetExpenseById(Guid id) =>\n    Result.TryCatch(\n        _httpClient.GetJson<Expense>(RootUrl + $\"/expenses/{id}\"),\n        ex => Errors.Error($\"Could not get the expence with id {id}\", exception: ex) // You can add more error details here\n    );\n\n\n\nWith the syntactic sugar provided by the extension methods you can write code that focuses mostly on the domain problem you are trying to solve. It leads to better understanding of the problem and better quality of the software.\n\n\nHow to use it\n\n\nTODO\n\n\nSummary\n\n\nUsing the \nResult<T>\n type won't prevent all of the exceptions bubbling up in the application - you may always miss some case. That's why you should have some global exception handler that will catch such cases and help to nail them down (e.g. by logging details and notifying responsible people). Having said that, if used correctly and system-wide, it should help to minimize potential bugs due to non-handled errors. It helps to reason about the code by favoring explicitness in the important aspects (like potential errors) while hiding less important details under the hood (in the related functions).",
            "title": "Result"
        },
        {
            "location": "/result/#monacscoreresult",
            "text": "Result<T>  type is a monad encapsulating common case when function call may end up with success or error. It has two possible states - one representing successful execution and a value being returned ( Ok ) and the other one representing error in execution ( Error ). You can find some similarities to Either, IO or Task monads, if you're familiar with any of those. It is meant to inform consumer of the function that the execution may not finish successfully (very often due to external side effects) and suggests handling such case on the consumer side. The most common examples would be any functions performing IO tasks. If such operation fails, the author of the function should provide all needed details in the  Error  property, described by the  ErrorDetails  class .",
            "title": "Monacs.Core.Result"
        },
        {
            "location": "/result/#when-to-use-it",
            "text": "Whenever you are creating a function which calls other functions that are known to throw exceptions or return errors of other kind, you face a dillema. You can either let the error to bubble up or handle it in-place. With the first approach in most cases you lose the explicitness, as you don't inform consumers that they should handle the error. There is always a problem when is the right moment to stop bubbling up which often leads to unhandled exceptions.  public Expense GetExpenseById(Guid id) =>\n    _httpClient.GetJson<Expense>(RootUrl + $\"/expenses/{id}\"); // Happy path, no exception handling  The solution for this could be handling the exception at the source, so the second approach. In this case the problem is usually deciding what kind of value you should return to the calling function, or how to stop further execution without breaking whole application.  public Expense GetExpenseById(Guid id)\n{\n    try\n    {\n        return _httpClient.GetJson<Expense>(RootUrl + $\"/expenses/{id}\"); // Happy path, no exception handling\n    }\n    catch (Exception ex)\n    {\n        _logger.Error($\"Could not get the expence with id {id}\", ex);\n        throw; // bubble up anyway\n        // or\n        return null; // return evil value\n    }\n}  This is where  Result<T>  comes in. You can handle the exception close to the source, provide meaningful error details and inform calling function about the failure.  public Result<Expense> GetExpenseById(Guid id) =>\n    Result.TryCatch(\n        _httpClient.GetJson<Expense>(RootUrl + $\"/expenses/{id}\"),\n        ex => Errors.Error($\"Could not get the expence with id {id}\", exception: ex) // You can add more error details here\n    );  With the syntactic sugar provided by the extension methods you can write code that focuses mostly on the domain problem you are trying to solve. It leads to better understanding of the problem and better quality of the software.",
            "title": "When to use it"
        },
        {
            "location": "/result/#how-to-use-it",
            "text": "TODO",
            "title": "How to use it"
        },
        {
            "location": "/result/#summary",
            "text": "Using the  Result<T>  type won't prevent all of the exceptions bubbling up in the application - you may always miss some case. That's why you should have some global exception handler that will catch such cases and help to nail them down (e.g. by logging details and notifying responsible people). Having said that, if used correctly and system-wide, it should help to minimize potential bugs due to non-handled errors. It helps to reason about the code by favoring explicitness in the important aspects (like potential errors) while hiding less important details under the hood (in the related functions).",
            "title": "Summary"
        },
        {
            "location": "/errors/",
            "text": "Monacs.Core.ErrorDetails\n\n\nErrorDetails\n type contains the description of the error that occured within the application. It is required by the [\nResult<T>\n type] in the \nError\n case. To construct the instance of this type you need to use static factory methods from the \nErrors\n class.\n\n\nErrorDetails\n contains several fields that help to describe the error to handle or log it properly in the later stage of the application execution. All fields apart from \nLevel\n are optional.",
            "title": "ErrorDetails"
        },
        {
            "location": "/errors/#monacscoreerrordetails",
            "text": "ErrorDetails  type contains the description of the error that occured within the application. It is required by the [ Result<T>  type] in the  Error  case. To construct the instance of this type you need to use static factory methods from the  Errors  class.  ErrorDetails  contains several fields that help to describe the error to handle or log it properly in the later stage of the application execution. All fields apart from  Level  are optional.",
            "title": "Monacs.Core.ErrorDetails"
        },
        {
            "location": "/glossary/",
            "text": "Glossary\n\n\nTo fully leverage the potential of this library, you'll need to get familiar with a few simple concepts. Once you get through them, everything about this library should be pretty obvious.\n\n\n(Don't fear the) Monad\n\n\nThe M Word. It's been a topic of countless discussions, jokes and even flamewars. You can look at the monad from many perspectives, but the perspective this library encourages is pretty simple: Monad is a combination of a type (e.g. Option) and a collection of functions around this type (like Map and Bind).\n\n\nActually, as a .NET developer you've probably used at least a couple of monads. \nIEnumerable<T>\n with LINQ is actually a monad. TPL and async/await workflow is a monad as well. And if you had chance to use Reactive Extensions and \nIObservable<T>\n type, then yes, it's a proper monad too.\n\n\nYou may find quite a few similarities between LINQ and what you'll find in this library, although the naming is a bit different. For example, both LINQ and Rx use \nSelect()\n name for the function that makes a projection of an encapsulated value to the value of (potentially) other type. In Monacs you'll find it under the name \nMap()\n, which is quite common across FP languages.\n\n\nHigher order functions\n\n\nThis is another complicated name for a pretty simple concept. Higher order function is just a function which takes another function as a parameter. And again, if you've used LINQ, TPL or Rx you're probably quite familiar with this idea and I think it doesn't require more explanation.\n\n\nValue types\n\n\nAs you may know, there are two kinds of types in C# - reference types, such as \nSystem.Object\n or any class you write, and value types, such as \nSystem.Int32\n or enums. One particular thing that is very often underestimated by developers is the ability to create your own value types - structs. Apart from memory management differences, the key distinction between struct and class is the default value - the problematic null in reference type is substituted by the default value you create when designing a struct. And while you don't want to go and replace all your classes with structs, there are certain places where it can make a huge difference to not have to deal with (implicit) null.\n\n\nThe power of extension methods\n\n\nOne of the most important features of C# that allowed to build this library is extension methods. Having the possibility to extend any type with additional methods from virtually any place gives us the flexibility to build modular fluent APIs around simple types.\n\n\nusing static\n imports\n\n\nThere is one particular feature of C# language that can significantly reduce the amount of code you have to write when you use the same static class multiple times. Take a look at an example:\n\n\nnamespace Monacs.Samples\n{\n    using System;\n\n    public class Sample1\n    {\n        TODO\n    }\n}\n\n\n\nTODO",
            "title": "Glossary"
        },
        {
            "location": "/glossary/#glossary",
            "text": "To fully leverage the potential of this library, you'll need to get familiar with a few simple concepts. Once you get through them, everything about this library should be pretty obvious.",
            "title": "Glossary"
        },
        {
            "location": "/glossary/#dont-fear-the-monad",
            "text": "The M Word. It's been a topic of countless discussions, jokes and even flamewars. You can look at the monad from many perspectives, but the perspective this library encourages is pretty simple: Monad is a combination of a type (e.g. Option) and a collection of functions around this type (like Map and Bind).  Actually, as a .NET developer you've probably used at least a couple of monads.  IEnumerable<T>  with LINQ is actually a monad. TPL and async/await workflow is a monad as well. And if you had chance to use Reactive Extensions and  IObservable<T>  type, then yes, it's a proper monad too.  You may find quite a few similarities between LINQ and what you'll find in this library, although the naming is a bit different. For example, both LINQ and Rx use  Select()  name for the function that makes a projection of an encapsulated value to the value of (potentially) other type. In Monacs you'll find it under the name  Map() , which is quite common across FP languages.",
            "title": "(Don't fear the) Monad"
        },
        {
            "location": "/glossary/#higher-order-functions",
            "text": "This is another complicated name for a pretty simple concept. Higher order function is just a function which takes another function as a parameter. And again, if you've used LINQ, TPL or Rx you're probably quite familiar with this idea and I think it doesn't require more explanation.",
            "title": "Higher order functions"
        },
        {
            "location": "/glossary/#value-types",
            "text": "As you may know, there are two kinds of types in C# - reference types, such as  System.Object  or any class you write, and value types, such as  System.Int32  or enums. One particular thing that is very often underestimated by developers is the ability to create your own value types - structs. Apart from memory management differences, the key distinction between struct and class is the default value - the problematic null in reference type is substituted by the default value you create when designing a struct. And while you don't want to go and replace all your classes with structs, there are certain places where it can make a huge difference to not have to deal with (implicit) null.",
            "title": "Value types"
        },
        {
            "location": "/glossary/#the-power-of-extension-methods",
            "text": "One of the most important features of C# that allowed to build this library is extension methods. Having the possibility to extend any type with additional methods from virtually any place gives us the flexibility to build modular fluent APIs around simple types.",
            "title": "The power of extension methods"
        },
        {
            "location": "/glossary/#using-static-imports",
            "text": "There is one particular feature of C# language that can significantly reduce the amount of code you have to write when you use the same static class multiple times. Take a look at an example:  namespace Monacs.Samples\n{\n    using System;\n\n    public class Sample1\n    {\n        TODO\n    }\n}  TODO",
            "title": "using static imports"
        },
        {
            "location": "/apidoc/",
            "text": "ErrorLevel\n\n\nenum Monacs.Core.ErrorLevel\n\n\nRepresents the severity of the error.\n\n\nEnum Values\n\n\n\n\nTrace\n\n\nDebug\n\n\nInfo\n\n\nWarn\n\n\nError\n\n\nFatal\n\n\n\n\n\n\n\n\nErrors\n\n\nclass Monacs.Core.Errors\n\n\nContains factory methods to create instances of \nMonacs.Core.ErrorDetails\n in a more convenient way.\n\n\nStatic Methods\n\n\n\n\n\n\nErrorDetails\n \nTrace\n \n([String message], [String key], [Exception exception], [Object metadata])\n\n  Creates \nMonacs.Core.ErrorDetails\n with level \nMonacs.Core.ErrorLevel.Trace\n .  \n\n\n\n\n\n\n\n\nErrorDetails\n \nDebug\n \n([String message], [String key], [Exception exception], [Object metadata])\n\n  Creates \nMonacs.Core.ErrorDetails\n with level \nMonacs.Core.ErrorLevel.Debug\n .  \n\n\n\n\n\n\n\n\nErrorDetails\n \nInfo\n \n([String message], [String key], [Exception exception], [Object metadata])\n\n  Creates \nMonacs.Core.ErrorDetails\n with level \nMonacs.Core.ErrorLevel.Info\n .  \n\n\n\n\n\n\n\n\nErrorDetails\n \nWarn\n \n([String message], [String key], [Exception exception], [Object metadata])\n\n  Creates \nMonacs.Core.ErrorDetails\n with level \nMonacs.Core.ErrorLevel.Warn\n .  \n\n\n\n\n\n\n\n\nErrorDetails\n \nError\n \n([String message], [String key], [Exception exception], [Object metadata])\n\n  Creates \nMonacs.Core.ErrorDetails\n with level \nMonacs.Core.ErrorLevel.Error\n .  \n\n\n\n\n\n\n\n\nErrorDetails\n \nFatal\n \n([String message], [String key], [Exception exception], [Object metadata])\n\n  Creates \nMonacs.Core.ErrorDetails\n with level \nMonacs.Core.ErrorLevel.Fatal\n .  \n\n\n\n\n\n\n\n\nOption\n\n\nclass Monacs.Core.Option\n\n\nContains the set of extensions to work with the [Monacs.Core.Option\n1](#Monacs.Core.Option\n1) type.\n\n\nStatic Methods\n\n\n\n\n\n\nOption<T>\n \nSome\n \n(T value)\n  \n\n\n\n\n\n\n\n\nOption<T>\n \nNone\n \n()\n  \n\n\n\n\n\n\n\n\nOption<T>\n \nOfObject\n \n(T value)\n  \n\n\n\n\n\n\n\n\nOption<T>\n \nToOption\n \n(T value)\n  \n\n\n\n\n\n\n\n\nOption<T>\n \nOfNullable\n \n(Nullable<T> value)\n  \n\n\n\n\n\n\n\n\nOption<T>\n \nToOption\n \n(Nullable<T> value)\n  \n\n\n\n\n\n\n\n\nNullable<T>\n \nToNullable\n \n(Option<T> value)\n  \n\n\n\n\n\n\n\n\nOption<String>\n \nOfString\n \n(String value)\n\n  Converts the string value to the [Monacs.Core.Option\n1](#Monacs.Core.Option\n1) type.\nIf the value is null or empty string, the None case is yielded.\nOtherwise Some case with provided value is returned.  \n\n\n\n\n\n\n\n\nOption<String>\n \nToOption\n \n(String value)\n\n  Converts the string value to the \nOption{string}\n type.\nIf the value is null or empty string, the None case is yielded.\nOtherwise Some case with provided value is returned.\n\n  Extension method variant of \nMonacs.Core.Option.OfString(System.String)\n \n\n\n\n\n\n\n\n\nOption<T>\n \nOfResult\n \n(Result<T> value)\n  \n\n\n\n\n\n\n\n\nOption<T>\n \nToOption\n \n(Result<T> value)\n  \n\n\n\n\n\n\n\n\nOption<TValue>\n \nTryGetOption\n \n(IDictionary<TKey, TValue> dictionary, TKey key)\n  \n\n\n\n\n\n\n\n\nOption<IEnumerable<TValue>>\n \nTryGetOption\n \n(ILookup<TKey, TValue> lookup, TKey key)\n  \n\n\n\n\n\n\n\n\nTOut\n \nMatch\n \n(Option<TIn> option, Func<TIn, TOut> some, Func<TOut> none)\n  \n\n\n\n\n\n\n\n\nTOut\n \nMatchTo\n \n(Option<TIn> option, TOut some, TOut none)\n  \n\n\n\n\n\n\n\n\nOption<TOut>\n \nBind\n \n(Option<TIn> option, Func<TIn, Option<TOut>> binder)\n  \n\n\n\n\n\n\n\n\nOption<TOut>\n \nMap\n \n(Option<TIn> option, Func<TIn, TOut> mapper)\n  \n\n\n\n\n\n\n\n\nT\n \nGetOrDefault\n \n(Option<T> option, [T whenNone])\n  \n\n\n\n\n\n\n\n\nTOut\n \nGetOrDefault\n \n(Option<TIn> option, Func<TIn, TOut> getter, [TOut whenNone])\n  \n\n\n\n\n\n\n\n\nOption<T>\n \nDo\n \n(Option<T> option, Action<T> action)\n  \n\n\n\n\n\n\n\n\nOption<T>\n \nDoWhenNone\n \n(Option<T> option, Action action)\n  \n\n\n\n\n\n\n\n\nIEnumerable<T>\n \nChoose\n \n(IEnumerable<Option<T>> items)\n  \n\n\n\n\n\n\n\n\nOption<IEnumerable<T>>\n \nSequence\n \n(IEnumerable<Option<T>> items)\n  \n\n\n\n\n\n\n\n\nOption<T>\n \nTryFind\n \n(IEnumerable<T> items, Func<T, Boolean> predicate)\n  \n\n\n\n\n\n\n\n\nOption<T>\n \nTryFirst\n \n(IEnumerable<T> items)\n  \n\n\n\n\n\n\n\n\nOption<T>\n \nTryElementAt\n \n(IEnumerable<T> items, Int32 index)\n  \n\n\n\n\n\n\n\n\nResult\n\n\nclass Monacs.Core.Result\n\n\nContains the set of extensions to work with the [Monacs.Core.Result\n1](#Monacs.Core.Result\n1) type.\n\n\nStatic Methods\n\n\n\n\n\n\nResult<T>\n \nOk\n \n(T value)\n  \n\n\n\n\n\n\n\n\nResult<T>\n \nError\n \n(ErrorDetails error)\n  \n\n\n\n\n\n\n\n\nResult<T>\n \nOfObject\n \n(T value, ErrorDetails error)\n  \n\n\n\n\n\n\n\n\nResult<T>\n \nOfObject\n \n(T value, Func<ErrorDetails> errorFunc)\n  \n\n\n\n\n\n\n\n\nResult<T>\n \nToResult\n \n(T value, ErrorDetails error)\n  \n\n\n\n\n\n\n\n\nResult<T>\n \nToResult\n \n(T value, Func<ErrorDetails> errorFunc)\n  \n\n\n\n\n\n\n\n\nResult<T>\n \nOfNullable\n \n(Nullable<T> value, ErrorDetails error)\n  \n\n\n\n\n\n\n\n\nResult<T>\n \nOfNullable\n \n(Nullable<T> value, Func<ErrorDetails> errorFunc)\n  \n\n\n\n\n\n\n\n\nResult<T>\n \nToResult\n \n(Nullable<T> value, ErrorDetails error)\n  \n\n\n\n\n\n\n\n\nResult<T>\n \nToResult\n \n(Nullable<T> value, Func<ErrorDetails> errorFunc)\n  \n\n\n\n\n\n\n\n\nResult<String>\n \nOfString\n \n(String value, ErrorDetails error)\n\n  Converts the string value to the [Monacs.Core.Result\n1](#Monacs.Core.Result\n1) type.\nIf the value is null or empty string, the Error case is yielded.\nOtherwise Ok case with provided value is returned.  \n\n\n\n\n\n\n\n\nResult<String>\n \nOfString\n \n(String value, Func<ErrorDetails> errorFunc)\n  \n\n\n\n\n\n\n\n\nResult<String>\n \nToResult\n \n(String value, ErrorDetails error)\n\n  Converts the string value to the [Monacs.Core.Result\n1](#Monacs.Core.Result\n1) type.\nIf the value is null or empty string, the Error case is yielded.\nOtherwise Ok case with provided value is returned.\n\n  Extension method variant of \nMonacs.Core.Result.OfString(System.String,Monacs.Core.ErrorDetails)\n \n\n\n\n\n\n\n\n\nResult<String>\n \nToResult\n \n(String value, Func<ErrorDetails> errorFunc)\n  \n\n\n\n\n\n\n\n\nResult<T>\n \nOfOption\n \n(Option<T> value, ErrorDetails error)\n  \n\n\n\n\n\n\n\n\nResult<T>\n \nOfOption\n \n(Option<T> value, Func<ErrorDetails> errorFunc)\n  \n\n\n\n\n\n\n\n\nResult<T>\n \nToResult\n \n(Option<T> value, ErrorDetails error)\n  \n\n\n\n\n\n\n\n\nResult<T>\n \nToResult\n \n(Option<T> value, Func<ErrorDetails> errorFunc)\n  \n\n\n\n\n\n\n\n\nResult<TValue>\n \nTryGetResult\n \n(IDictionary<TKey, TValue> dictionary, TKey key, ErrorDetails error)\n  \n\n\n\n\n\n\n\n\nResult<TValue>\n \nTryGetResult\n \n(IDictionary<TKey, TValue> dictionary, TKey key, Func<TKey, ErrorDetails> errorFunc)\n  \n\n\n\n\n\n\n\n\nResult<IEnumerable<TValue>>\n \nTryGetResult\n \n(ILookup<TKey, TValue> lookup, TKey key, ErrorDetails error)\n  \n\n\n\n\n\n\n\n\nResult<IEnumerable<TValue>>\n \nTryGetResult\n \n(ILookup<TKey, TValue> lookup, TKey key, Func<TKey, ErrorDetails> errorFunc)\n  \n\n\n\n\n\n\n\n\nTOut\n \nMatch\n \n(Result<TIn> result, Func<TIn, TOut> ok, Func<ErrorDetails, TOut> error)\n  \n\n\n\n\n\n\n\n\nTOut\n \nMatchTo\n \n(Result<TIn> result, TOut ok, TOut error)\n  \n\n\n\n\n\n\n\n\nResult<TOut>\n \nBind\n \n(Result<TIn> result, Func<TIn, Result<TOut>> binder)\n  \n\n\n\n\n\n\n\n\nResult<TOut>\n \nMap\n \n(Result<TIn> result, Func<TIn, TOut> mapper)\n  \n\n\n\n\n\n\n\n\nT\n \nGetOrDefault\n \n(Result<T> result, [T whenError])\n  \n\n\n\n\n\n\n\n\nTOut\n \nGetOrDefault\n \n(Result<TIn> result, Func<TIn, TOut> getter, [TOut whenError])\n  \n\n\n\n\n\n\n\n\nResult<T>\n \nDo\n \n(Result<T> result, Action<T> action)\n  \n\n\n\n\n\n\n\n\nResult<T>\n \nDoWhenError\n \n(Result<T> result, Action<ErrorDetails> action)\n  \n\n\n\n\n\n\n\n\nIEnumerable<T>\n \nChoose\n \n(IEnumerable<Result<T>> items)\n  \n\n\n\n\n\n\n\n\nIEnumerable<ErrorDetails>\n \nChooseErrors\n \n(IEnumerable<Result<T>> items)\n  \n\n\n\n\n\n\n\n\nResult<IEnumerable<T>>\n \nSequence\n \n(IEnumerable<Result<T>> items)\n  \n\n\n\n\n\n\n\n\nResult<T>\n \nTryCatch\n \n(Func<T> func, Func<Exception, ErrorDetails> errorHandler)\n  \n\n\n\n\n\n\n\n\nResult<TOut>\n \nTryCatch\n \n(Result<TIn> result, Func<TIn, TOut> func, Func<TIn, Exception, ErrorDetails> errorHandler)\n  \n\n\n\n\n\n\n\n\nResult\n\n\nclass Monacs.Core.Unit.Result\n\n\nContains the set of extensions to work with the [Monacs.Core.Result\n1](#Monacs.Core.Result\n1) type.\n\n\nStatic Methods\n\n\n\n\n\n\nResult<Unit>\n \nOk\n \n()\n\n  Creates the Ok case instance of the [Monacs.Core.Result\n1](#Monacs.Core.Result\n1) .  \n\n\n\n\n\n\n\n\nResult<Unit>\n \nError\n \n(ErrorDetails error)\n\n  Creates the Error case instance of the [Monacs.Core.Result\n1](#Monacs.Core.Result\n1) type, containing error instead of value.  \n\n\n\n\n\n\n\n\nResult<Unit>\n \nIgnore\n \n(Result<T> result)\n  \n\n\n\n\n\n\n\n\nResult\n\n\nclass Monacs.Core.Async.Result\n\n\nContains the set of async extensions to work with the [Monacs.Core.Result\n1](#Monacs.Core.Result\n1) type.\n\n\nStatic Methods\n\n\n\n\n\n\nTask<Result<TOut>>\n \nBindAsync\n \n(Result<TIn> result, Func<TIn, Task<Result<TOut>>> binder)\n  \n\n\n\n\n\n\n\n\nTask<Result<TOut>>\n \nBindAsync\n \n(Task<Result<TIn>> result, Func<TIn, Task<Result<TOut>>> binder)\n  \n\n\n\n\n\n\n\n\nTask<Result<TOut>>\n \nBindAsync\n \n(Task<Result<TIn>> result, Func<TIn, Result<TOut>> binder)\n  \n\n\n\n\n\n\n\n\nTask<Result<TOut>>\n \nMapAsync\n \n(Result<TIn> result, Func<TIn, Task<TOut>> mapper)\n  \n\n\n\n\n\n\n\n\nTask<Result<TOut>>\n \nMapAsync\n \n(Task<Result<TIn>> result, Func<TIn, Task<TOut>> mapper)\n  \n\n\n\n\n\n\n\n\nTask<Result<TOut>>\n \nMapAsync\n \n(Task<Result<TIn>> result, Func<TIn, TOut> mapper)\n  \n\n\n\n\n\n\n\n\nTask<TOut>\n \nMatchAsync\n \n(Result<TIn> result, Func<TIn, Task<TOut>> ok, Func<ErrorDetails, Task<TOut>> error)\n  \n\n\n\n\n\n\n\n\nTask<TOut>\n \nMatchAsync\n \n(Result<TIn> result, Func<TIn, Task<TOut>> ok, Func<ErrorDetails, TOut> error)\n  \n\n\n\n\n\n\n\n\nTask<TOut>\n \nMatchAsync\n \n(Result<TIn> result, Func<TIn, TOut> ok, Func<ErrorDetails, Task<TOut>> error)\n  \n\n\n\n\n\n\n\n\nTask<TOut>\n \nMatchAsync\n \n(Task<Result<TIn>> result, Func<TIn, TOut> ok, Func<ErrorDetails, TOut> error)\n  \n\n\n\n\n\n\n\n\nTask<TOut>\n \nMatchAsync\n \n(Task<Result<TIn>> result, Func<TIn, Task<TOut>> ok, Func<ErrorDetails, Task<TOut>> error)\n  \n\n\n\n\n\n\n\n\nTask<TOut>\n \nMatchAsync\n \n(Task<Result<TIn>> result, Func<TIn, Task<TOut>> ok, Func<ErrorDetails, TOut> error)\n  \n\n\n\n\n\n\n\n\nTask<TOut>\n \nMatchAsync\n \n(Task<Result<TIn>> result, Func<TIn, TOut> ok, Func<ErrorDetails, Task<TOut>> error)\n  \n\n\n\n\n\n\n\n\nTask<Result<Unit>>\n \nIgnoreAsync\n \n(Task<Result<T>> result)\n  \n\n\n\n\n\n\n\n\nTask<Result<T>>\n \nDoAsync\n \n(Task<Result<T>> result, Action<T> action)\n  \n\n\n\n\n\n\n\n\nTask<Result<T>>\n \nDoAsync\n \n(Result<T> result, Func<T, Task> action)\n  \n\n\n\n\n\n\n\n\nTask<Result<T>>\n \nDoAsync\n \n(Task<Result<T>> result, Func<T, Task> action)\n  \n\n\n\n\n\n\n\n\nTask<Result<T>>\n \nDoWhenErrorAsync\n \n(Task<Result<T>> result, Action<ErrorDetails> action)\n  \n\n\n\n\n\n\n\n\nTask<Result<T>>\n \nDoWhenErrorAsync\n \n(Result<T> result, Func<ErrorDetails, Task> action)\n  \n\n\n\n\n\n\n\n\nTask<Result<T>>\n \nDoWhenErrorAsync\n \n(Task<Result<T>> result, Func<ErrorDetails, Task> action)\n  \n\n\n\n\n\n\n\n\nTask<Result<T>>\n \nFlipAsync\n \n(Result<Task<T>> result)\n  \n\n\n\n\n\n\n\n\nTask<Result<T>>\n \nTryCatchAsync\n \n(Func<Task<T>> func, Func<Exception, ErrorDetails> errorHandler)\n  \n\n\n\n\n\n\n\n\nTask<Result<TOut>>\n \nTryCatchAsync\n \n(Result<TIn> result, Func<TIn, Task<TOut>> func, Func<TIn, Exception, ErrorDetails> errorHandler)",
            "title": "API docs"
        },
        {
            "location": "/apidoc/#errorlevel",
            "text": "enum Monacs.Core.ErrorLevel  Represents the severity of the error.  Enum Values   Trace  Debug  Info  Warn  Error  Fatal",
            "title": "ErrorLevel"
        },
        {
            "location": "/apidoc/#errors",
            "text": "class Monacs.Core.Errors  Contains factory methods to create instances of  Monacs.Core.ErrorDetails  in a more convenient way.  Static Methods    ErrorDetails   Trace   ([String message], [String key], [Exception exception], [Object metadata]) \n  Creates  Monacs.Core.ErrorDetails  with level  Monacs.Core.ErrorLevel.Trace  .       ErrorDetails   Debug   ([String message], [String key], [Exception exception], [Object metadata]) \n  Creates  Monacs.Core.ErrorDetails  with level  Monacs.Core.ErrorLevel.Debug  .       ErrorDetails   Info   ([String message], [String key], [Exception exception], [Object metadata]) \n  Creates  Monacs.Core.ErrorDetails  with level  Monacs.Core.ErrorLevel.Info  .       ErrorDetails   Warn   ([String message], [String key], [Exception exception], [Object metadata]) \n  Creates  Monacs.Core.ErrorDetails  with level  Monacs.Core.ErrorLevel.Warn  .       ErrorDetails   Error   ([String message], [String key], [Exception exception], [Object metadata]) \n  Creates  Monacs.Core.ErrorDetails  with level  Monacs.Core.ErrorLevel.Error  .       ErrorDetails   Fatal   ([String message], [String key], [Exception exception], [Object metadata]) \n  Creates  Monacs.Core.ErrorDetails  with level  Monacs.Core.ErrorLevel.Fatal  .",
            "title": "Errors"
        },
        {
            "location": "/apidoc/#option",
            "text": "class Monacs.Core.Option  Contains the set of extensions to work with the [Monacs.Core.Option 1](#Monacs.Core.Option 1) type.  Static Methods    Option<T>   Some   (T value)        Option<T>   None   ()        Option<T>   OfObject   (T value)        Option<T>   ToOption   (T value)        Option<T>   OfNullable   (Nullable<T> value)        Option<T>   ToOption   (Nullable<T> value)        Nullable<T>   ToNullable   (Option<T> value)        Option<String>   OfString   (String value) \n  Converts the string value to the [Monacs.Core.Option 1](#Monacs.Core.Option 1) type.\nIf the value is null or empty string, the None case is yielded.\nOtherwise Some case with provided value is returned.       Option<String>   ToOption   (String value) \n  Converts the string value to the  Option{string}  type.\nIf the value is null or empty string, the None case is yielded.\nOtherwise Some case with provided value is returned. \n  Extension method variant of  Monacs.Core.Option.OfString(System.String)       Option<T>   OfResult   (Result<T> value)        Option<T>   ToOption   (Result<T> value)        Option<TValue>   TryGetOption   (IDictionary<TKey, TValue> dictionary, TKey key)        Option<IEnumerable<TValue>>   TryGetOption   (ILookup<TKey, TValue> lookup, TKey key)        TOut   Match   (Option<TIn> option, Func<TIn, TOut> some, Func<TOut> none)        TOut   MatchTo   (Option<TIn> option, TOut some, TOut none)        Option<TOut>   Bind   (Option<TIn> option, Func<TIn, Option<TOut>> binder)        Option<TOut>   Map   (Option<TIn> option, Func<TIn, TOut> mapper)        T   GetOrDefault   (Option<T> option, [T whenNone])        TOut   GetOrDefault   (Option<TIn> option, Func<TIn, TOut> getter, [TOut whenNone])        Option<T>   Do   (Option<T> option, Action<T> action)        Option<T>   DoWhenNone   (Option<T> option, Action action)        IEnumerable<T>   Choose   (IEnumerable<Option<T>> items)        Option<IEnumerable<T>>   Sequence   (IEnumerable<Option<T>> items)        Option<T>   TryFind   (IEnumerable<T> items, Func<T, Boolean> predicate)        Option<T>   TryFirst   (IEnumerable<T> items)        Option<T>   TryElementAt   (IEnumerable<T> items, Int32 index)",
            "title": "Option"
        },
        {
            "location": "/apidoc/#result",
            "text": "class Monacs.Core.Result  Contains the set of extensions to work with the [Monacs.Core.Result 1](#Monacs.Core.Result 1) type.  Static Methods    Result<T>   Ok   (T value)        Result<T>   Error   (ErrorDetails error)        Result<T>   OfObject   (T value, ErrorDetails error)        Result<T>   OfObject   (T value, Func<ErrorDetails> errorFunc)        Result<T>   ToResult   (T value, ErrorDetails error)        Result<T>   ToResult   (T value, Func<ErrorDetails> errorFunc)        Result<T>   OfNullable   (Nullable<T> value, ErrorDetails error)        Result<T>   OfNullable   (Nullable<T> value, Func<ErrorDetails> errorFunc)        Result<T>   ToResult   (Nullable<T> value, ErrorDetails error)        Result<T>   ToResult   (Nullable<T> value, Func<ErrorDetails> errorFunc)        Result<String>   OfString   (String value, ErrorDetails error) \n  Converts the string value to the [Monacs.Core.Result 1](#Monacs.Core.Result 1) type.\nIf the value is null or empty string, the Error case is yielded.\nOtherwise Ok case with provided value is returned.       Result<String>   OfString   (String value, Func<ErrorDetails> errorFunc)        Result<String>   ToResult   (String value, ErrorDetails error) \n  Converts the string value to the [Monacs.Core.Result 1](#Monacs.Core.Result 1) type.\nIf the value is null or empty string, the Error case is yielded.\nOtherwise Ok case with provided value is returned. \n  Extension method variant of  Monacs.Core.Result.OfString(System.String,Monacs.Core.ErrorDetails)       Result<String>   ToResult   (String value, Func<ErrorDetails> errorFunc)        Result<T>   OfOption   (Option<T> value, ErrorDetails error)        Result<T>   OfOption   (Option<T> value, Func<ErrorDetails> errorFunc)        Result<T>   ToResult   (Option<T> value, ErrorDetails error)        Result<T>   ToResult   (Option<T> value, Func<ErrorDetails> errorFunc)        Result<TValue>   TryGetResult   (IDictionary<TKey, TValue> dictionary, TKey key, ErrorDetails error)        Result<TValue>   TryGetResult   (IDictionary<TKey, TValue> dictionary, TKey key, Func<TKey, ErrorDetails> errorFunc)        Result<IEnumerable<TValue>>   TryGetResult   (ILookup<TKey, TValue> lookup, TKey key, ErrorDetails error)        Result<IEnumerable<TValue>>   TryGetResult   (ILookup<TKey, TValue> lookup, TKey key, Func<TKey, ErrorDetails> errorFunc)        TOut   Match   (Result<TIn> result, Func<TIn, TOut> ok, Func<ErrorDetails, TOut> error)        TOut   MatchTo   (Result<TIn> result, TOut ok, TOut error)        Result<TOut>   Bind   (Result<TIn> result, Func<TIn, Result<TOut>> binder)        Result<TOut>   Map   (Result<TIn> result, Func<TIn, TOut> mapper)        T   GetOrDefault   (Result<T> result, [T whenError])        TOut   GetOrDefault   (Result<TIn> result, Func<TIn, TOut> getter, [TOut whenError])        Result<T>   Do   (Result<T> result, Action<T> action)        Result<T>   DoWhenError   (Result<T> result, Action<ErrorDetails> action)        IEnumerable<T>   Choose   (IEnumerable<Result<T>> items)        IEnumerable<ErrorDetails>   ChooseErrors   (IEnumerable<Result<T>> items)        Result<IEnumerable<T>>   Sequence   (IEnumerable<Result<T>> items)        Result<T>   TryCatch   (Func<T> func, Func<Exception, ErrorDetails> errorHandler)        Result<TOut>   TryCatch   (Result<TIn> result, Func<TIn, TOut> func, Func<TIn, Exception, ErrorDetails> errorHandler)",
            "title": "Result"
        },
        {
            "location": "/apidoc/#result_1",
            "text": "class Monacs.Core.Unit.Result  Contains the set of extensions to work with the [Monacs.Core.Result 1](#Monacs.Core.Result 1) type.  Static Methods    Result<Unit>   Ok   () \n  Creates the Ok case instance of the [Monacs.Core.Result 1](#Monacs.Core.Result 1) .       Result<Unit>   Error   (ErrorDetails error) \n  Creates the Error case instance of the [Monacs.Core.Result 1](#Monacs.Core.Result 1) type, containing error instead of value.       Result<Unit>   Ignore   (Result<T> result)",
            "title": "Result"
        },
        {
            "location": "/apidoc/#result_2",
            "text": "class Monacs.Core.Async.Result  Contains the set of async extensions to work with the [Monacs.Core.Result 1](#Monacs.Core.Result 1) type.  Static Methods    Task<Result<TOut>>   BindAsync   (Result<TIn> result, Func<TIn, Task<Result<TOut>>> binder)        Task<Result<TOut>>   BindAsync   (Task<Result<TIn>> result, Func<TIn, Task<Result<TOut>>> binder)        Task<Result<TOut>>   BindAsync   (Task<Result<TIn>> result, Func<TIn, Result<TOut>> binder)        Task<Result<TOut>>   MapAsync   (Result<TIn> result, Func<TIn, Task<TOut>> mapper)        Task<Result<TOut>>   MapAsync   (Task<Result<TIn>> result, Func<TIn, Task<TOut>> mapper)        Task<Result<TOut>>   MapAsync   (Task<Result<TIn>> result, Func<TIn, TOut> mapper)        Task<TOut>   MatchAsync   (Result<TIn> result, Func<TIn, Task<TOut>> ok, Func<ErrorDetails, Task<TOut>> error)        Task<TOut>   MatchAsync   (Result<TIn> result, Func<TIn, Task<TOut>> ok, Func<ErrorDetails, TOut> error)        Task<TOut>   MatchAsync   (Result<TIn> result, Func<TIn, TOut> ok, Func<ErrorDetails, Task<TOut>> error)        Task<TOut>   MatchAsync   (Task<Result<TIn>> result, Func<TIn, TOut> ok, Func<ErrorDetails, TOut> error)        Task<TOut>   MatchAsync   (Task<Result<TIn>> result, Func<TIn, Task<TOut>> ok, Func<ErrorDetails, Task<TOut>> error)        Task<TOut>   MatchAsync   (Task<Result<TIn>> result, Func<TIn, Task<TOut>> ok, Func<ErrorDetails, TOut> error)        Task<TOut>   MatchAsync   (Task<Result<TIn>> result, Func<TIn, TOut> ok, Func<ErrorDetails, Task<TOut>> error)        Task<Result<Unit>>   IgnoreAsync   (Task<Result<T>> result)        Task<Result<T>>   DoAsync   (Task<Result<T>> result, Action<T> action)        Task<Result<T>>   DoAsync   (Result<T> result, Func<T, Task> action)        Task<Result<T>>   DoAsync   (Task<Result<T>> result, Func<T, Task> action)        Task<Result<T>>   DoWhenErrorAsync   (Task<Result<T>> result, Action<ErrorDetails> action)        Task<Result<T>>   DoWhenErrorAsync   (Result<T> result, Func<ErrorDetails, Task> action)        Task<Result<T>>   DoWhenErrorAsync   (Task<Result<T>> result, Func<ErrorDetails, Task> action)        Task<Result<T>>   FlipAsync   (Result<Task<T>> result)        Task<Result<T>>   TryCatchAsync   (Func<Task<T>> func, Func<Exception, ErrorDetails> errorHandler)        Task<Result<TOut>>   TryCatchAsync   (Result<TIn> result, Func<TIn, Task<TOut>> func, Func<TIn, Exception, ErrorDetails> errorHandler)",
            "title": "Result"
        }
    ]
}